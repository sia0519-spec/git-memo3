# 브랜치(Branch)
- 독립적인 작업 공간이다.(브랜치끼리 영향을 주지 않는다.)
- 브랜치를 새로 만들면 현재 작업 내용을 복사해서 새로운 작업을 시작할 수 있고, 원본을 유지할 수 있다.
- 브랜치를 새로 만드는 것은 평행세계를 만드는 것과 유사하다.

## main 브랜치
- `git init`으로 깃 저장소를 만들면 기본적으로 생성되고, 사용하는 브랜치
- 과거에는 master 브랜치가 기본 브랜치였음

## 브랜치 주요 명령어
1. 브랜치 생성/확인
   - git branch : 브랜치 목록 확인
   - git branch [이름] : 새 브랜치 생성
2. 브랜치 이동
   - git checkout [이름] : 브랜치 이동
   - git checkout -b [이름] : 브랜치를 새로 생성하면서 이동
   브랜치 생성+이동
3. 브랜치 삭제
   - git branch-d [이름] : 브랜치 삭제
   - git branck -D [이름] : 강제 삭제
4. 브랜치 병합
   - git merge [브랜치명] : 현재 내가 위치한 브랜치에 병합
   - 예 : git merge login - 현재 내가 위치한 브랜치의 login 브랜치를 병합

### 상황1
1. 회사에서 운영 중인 웹사이트가 있다.
2. 새로운 챗봇 기능을 구현하기 위해 새로운 브랜치(chatbot)를 생성했다.
3. chatbot 브랜치에서 작업을 한다.
4. 새벽에 갑자기 운영중인 웹사이트에서 버그가 발생했다.
5. chatbot 브랜치에서 작업중인 내용을 중단하고, main에서 새로운 브랜치 (hotfix)를 생성한다.
6. hotfix 브랜치에서 버그를 급하게 수정하고 main 브랜치에 merge한다.
7. 다시 chatbot브랜치로 이동하여 하던 일을 계속 진행한다.

## 브랜치 이동할 때 주의사항
1. 브랜치 이동 전 상태 확인
   - `git status`로 현재 파일 상태 확인
   - 작업 중인 파일이 있는지, 커밋되지 않은 변경사항이 있는지 확인
2. 작업 중인 파일 처리
   - 커밋되지 않은 파일은 다른 브랜치로 함께 이동된다.
   - 그러므로 작업 중인 파일을 처리한 후 이동한다.
3. 안전한 브랜치 이동 방법   
   - 현재 작업을 완성하지 못했어도 오류가 나지 않는 상태로 마무리 한다.
   (주석을 활용하는 등)
   - 작업 내용을 처리하는 가장 쉽고 확실한 방법은 commit이다.
   - 즉, 커밋 후 브랜치를 이동하기

# 병합(Merge)의 종류
1. Fast-Forward Merge
- 가장 단순한 병합 방식
- 병합하려는 브랜치의 변경사항이 없을 때 발생
- 병합 당하는 브랜치의 커밋을 그대로 가져오는 방식
- 별도의 병합 커밋이 생기지 않음
2. 3-way Merge
- 두 브랜치와 공통 조상 커밋을 비교하는 방식
- 양쪽 브랜치에 새로운 커밋이 있을 때 발생
- 자동으로 병합 후 새로운 병합 커밋 생성
- 충돌이 없다면 자동으로 처리됨

# 충돌(conflict)란?
1. 충돌이 발생하는 경우
- 3-way Merge에서 발생됨
- 양쪽 브랜치에서 같은 파일의 같은 부분을 다르게 수정
- Git이 어느 것을 선택할지 판단 불가
- 사용자가 직접 선택해야함
2. 충돌 표시 형식
<<<<<<<<< HEAD
현재 브랜치의 내용
=============
병합할 브랜치의 내용
>>>>>>>>>branch 이름

해결하고 커밋해야함! -> 그래야 merge commit됨

------------------------------------------------
# Remote 저장소
1. 원격 저장소의 구조
   - 원격 저장소도 로컬처럼 브랜치를 가짐
   - 로컬의 브랜치와 원격의 브랜치는 독립적
2. 동기화 과정
   - pull : 변경사항을 로컬로 가져온 후 merge
   - push : 로컬의 변경사항을 원격에 업로드 후  merge(Fas-Forward만 가능)
3. 충돌이 발생하는 경우
   - pull : 원격과 로컬이 같은 부분을 다르게 수정
   - push : 충돌 상황이 발생되면, push가 안됨(pull을 먼저해야함)
   원격에 새로운 커밋이 있는 경우에 충돌 상황이 발생됨

# Pull 전략 설정하기

1. merge 방식 (일반적인 방법)
   - 기본으로 설정하기 : `git config pull.rebase false`
   - pull할 때 옵션주기 : `git pull --no-rebase origin main`
   - 일반적인 병합 커밋 생성
   - 히스토리가 보존됨
   - 가장 안전한 방법
2. rebase 방식
   - 기본으로 설정하기 : `git config pull.rebase true`
   - pull할 때 옵션주기 : git pull --rebase origin main
   - 커밋 히스토리를 한 줄로 정리, 깔끔한 히스토리를 유지할 수 있음 (기존 커밋을 재작성함!)
   - 협업할 때 권장하지 않음, 잘 모르고 rebase를 사용하면 팀원에게 욕먹을 가능성이 높음.
3. fast-forward only
   - 기본으로 설정하기 : `git config pull.ff only`
   - pull할 때 옵션주기 : `git pull --ff-only origin main`
   - 충돌 가능성 있으면 거부!
   - 가장 엄격한 방식이기 때문에 안전하지만, 제한적이라 사용하기 불편함

-----------------------------------------------------------------------------------------

# Fetch란?
- `git fetch [원격저장소][브랜치]`
- 원격의 변경사항을 확인만 할 때 사용하는 명령어(원격 저장소의 변경사항을 가져온다.)
- 실제 파일은 가져오지 않음

## Fetch 사용 목적
- 원격의 변경사항을 안전하게 확인
- 병합/pull 전에 코드 검토
- 충돌 가능성 미리 확인

## Fetch와 Pull 차이
- Pull = Fetch + Merge
- Fetch : 변경사항 확인만 함
- Pull : 변경사항을 가져와서 병합까지 함

## 관련 명령어
- `git branch --all` : 원격 브랜치 목록까지 조회
- `git log --all` : 원격 저장소+로컬 저장소의 모든 브랜치 로그를 조회
- `git diff [브랜치1] [브랜치2]` : 두 브랜치간 코드 차이 비교

----------------------------------------------------------------------------------------
# GitHub의 주요 기능

## Fork
- 내 소유가 아닌 저장소를 내 계정의 저장소로 복사해오는 것
- 복사본은  내 소유의 저장소이므로 마음대로 수정  가능
- 원본 저장소와 연결되어 정보를 유지함(원본이 어느 저장소인지)

## Organization(조직)
- 여러 사람이 공유하는 저장소 그룹(하나의 팀을 구성하는것)
- 팀/회사 단위의 프로젝트 관리에 적합
- 주요 기능 :
   -팀 구성 권한 관리
   -Organization Repository(조직이 공유하는 저장소)생성 가능

## Pull Request(PR)
- 코드 변경사항을 병합 요청하는 기능
- 변경사항 토론 및 피드백 가능
---------------------------------------------------------------------------------------
# 팀장이 처음에 하는 일(세팅)
1. Organization 생성

   - GitHub 메인 → 프로필 → Your Organizations → New Organization
   - 무료 플랜 선택
   - Organization 이름, 이메일 설정

2. 팀원 초대

   - Organization 페이지 → People
   - Invite member 클릭
   - 팀원 이메일/아이디 검색, 입력
   - 권한 설정 (보통 Member 권한)

3. Repository 생성

   - Organization 페이지 → New repository
   - 이름 설정 (예: team-project)
   - Public/Private 선택
   - README.md 생성 체크

4. 기본 파일 설정(프로젝트 세팅)

   - 공용 저장소의 fork 버튼을 눌러 내 개인 저장소로 복제하기
   - 로컬에 프로젝트 폴더 만들고 클론 따기
     - `git clone [url] .`
   - 리모트 연결 확인하기
     - `git remote -v`
     - origin에 내 계정의 fork딴 저장소가 등록되어 있어야 함 (잘못되어 있다면 수정하기)
   - 공용 저장소도 리모트 연결하기
     - `git remote add [별칭] [공용 저장소 주소]`
     - `git remote -v` 로 다시 확인
   - .gitingnore 파일 생성 등 프로젝트 기본 구조 만들기
   - 변경사항 스테이징 → 커밋 → push(fork딴 origin으로 해야함)

5. 공용 저장소로 변경사항 PR 보내기

   - fork딴 저장소 → Pull requests
   - New pull request → 변경사항 확인 후(특히 충돌 없는지 확인) → Create pull request
   - PR 제목(무엇을 수정했는지 작성), 내용 설명(자세하게 무엇을 했는지 작성) → Create pull request

6. PR 요청 확인과 병합하기

   - 공용 저장소 → Pull requetsts에 숫자가 뜸
   - PR 목록 중 1개 선택
   - PR 설명과 Files changed에서 어떤 파일이 변경되었는지 대략적으로 파악 (특히 충돌 없는지 확인)
   - 이상이 없다면 Merge pull request

7. 팀원들에게 세팅 끝났다고 알려주기

# 팀원이 하는 일
1. 초대 수락

   - 이메일의 초대 링크 클릭
   - 또는 GitHub의 알림에서 수락

2. 팀장이 세팅을 다 끝내면, Fork 생성

   - Organization 저장소 방문
   - Fork 버튼 클릭해서 내 저장소로 복제하기

3. 로컬 환경 설정

   - 로컬에 프로젝트 폴더 만들고 클론 따기
     - `git clone [url] .`
   - 리모트 연결 확인하기
     - `git remote -v`
     - origin에 내 계정의 fork딴 저장소가 등록되어 있어야 함 (잘못되어 있다면 수정하기)
   - 공용 저장소도 리모트 연결하기
     - `git remote add [별칭] [공용 저장소 주소]`
     - `git remote -v` 로 다시 확인

# 세팅이 끝난 후

## 3. 작업할 때 순서 (팀장/팀원 공통)

- 이 순서는 어떤 git 전략을 사용하냐에 따라 바뀌는 내용이다.
- 우리는 가장 쉽고 직관적인 방법을 사용한다.(GitHub Flow)

1. 작업 시작 전 준비

   - main 브랜치로 이동 (제발 main브랜치에서 작업하지 마세요!)
   - [공용 저장소]에서 pull을 받아 최신화
   - 최신 상태의 main에서 작업용 브랜치 생성하기

2. 작업 진행

   - 작업용 브랜치에서만 작업!
   - 완료되면 커밋하고, 필요하다면 여러번 커밋해도 무관

3. [원격 저장소]에 push 준비

   - main 브랜치로 이동해서 [공용 저장소]에서 pull 받기 (최신화)
   - 작업 브랜치로 돌아와서(checkout) main을 병합(merge)하기
     - 충돌 발생하면 해결 후 커밋하기
     - 충돌 없으면 자동 커밋
   - [원격 저장소]에 Push 하기
     - `git push origin [작업 브랜치명]`
     - 작업 브랜치명과 동일한 브랜치를 만들면서 push하는 것

4. PR 생성하기
   - PR을 [공용 저장소] main으로 보내기
   - PR을 보낸 후 팀장에게 연락하기

## 4. PR받을 때 팀장이 하는 일

1. PR 요청 확인과 병합하기
   - 공용 저장소 → Pull requetsts에 숫자가 뜸
   - PR 목록 중 1개 선택
   - PR 설명과 Files changed에서 어떤 파일이 변경되었는지 대략적으로 파악 (특히 충돌 없는지 확인)
   - 이상이 없다면 Merge pull request, 이상이 있다면 해당 팀원에게 다시 보내라고 하기